#!/usr/bin/python
# -*- coding: utf-8 -*-

def print_concept_cmd():
    mm_concept = """
PU实模式（Real Mode）：实模式是 Intel 8086 引入的最初工作模式，是 CPU 上电后默认的模式，它提供了一种简单直接的方式访问内存，内存地址=段寄存器*16+偏移量（BIOS 初始化，bootloader）。
CPU保护模式（Protected Mode）：保护模式由 Intel 80286 引入，80386 起正式流行，支持内存保护、多任务、分页机制等现代操作系统特性，内核启动后会立即从实模式切换到保护模式。
虚拟地址（Virtual Address）：又称线性地址（Linear Address），是分页机制下，经过段机制转换后的地址，在开启分页时，线性地址会被转换为物理地址（用户程序看到的地址），虚拟地址被拆分为以下两部分：
	页号（Page Number）：查页表使用。
	页内偏移（Offset）：定位页内具体位置。
逻辑地址：逻辑地址是程序在运行时看到和使用的地址，在x86保护模式中，逻辑地址 = 段寄存器（CS、DS、SS 等） + 偏移地址，在分页机制下，逻辑地址通常就是虚拟地址。
物理地址（Physical Address）：实际访问内存芯片时使用的地址，通过内存管理单元（MMU）将虚拟地址映射到物理地址。
内存管理单元（Memory Management Unit）：是集成在 CPU 中的一个硬件模块，专门负责虚拟地址到物理地址的转换和内存访问控制，包含TLB、页表解析逻辑、访问权限控制单元、异常处理逻辑（访问非法或缺页时触发中断）。

程序中的段机制：./mytool.py --show c --item vas
用户空间地址（User Space）：用户程序可访问的内存区域，保护机制防止用户程序访问内核空间。
内核空间地址（Kernel Space）：操作系统核心代码使用的内存区域，受保护，用户态无法直接访问。
动态内存（dynamic memory）：


地址总线（Address Bus）：CPU通过地址总线发送内存地址。
数据总线（Data Bus）：CPU与内存之间传输数据。
控制总线（Control Bus）：用于发送读写等控制信号。
内存芯片：内存芯片只负责提供物理地址空间，并通过地址总线、控制总线读取或写入数据，芯片本身不会对存储单元进行分页，分页是操作系统和 MMU 层面实现的逻辑概念。


内存存储单元：一个存储单元通常是8bit（1Byte）。
页（Page）：虚拟内存被划分的小块，大小固定（常见4KB），结构体在 /linux-6.11.6/include/linux/mm_types.h 中被定义。
大页（Huge Page）：默认页大小是 4KB，但 Linux 也支持 2MB、1GB 等大页（Huge Pages），用于减少页表项数量、减少 TLB miss，提高性能。
页框（Page Frame）：物理内存被划分的小块，大小和页相同（有时叫做物理页）。
分页单元（Paging Unit）：把所有的 RAM 分成固定长度的页框（page frame）。
页表（Page Table）：记录了每一页虚拟地址对应的物理页框（Page Frame）的地址；每个进程有自己的页表，内核通过页表实现对物理内存的访问控制、隔离和共享；结构体在 /linux-6.11.6/include/linux/XXXXXXXXXXX.h 中被定义。
页表项（PTE: Page Table Entry）：包含映射关系和访问权限等信息。 
页错误（Page Fault）：当访问一个虚拟地址时，进程中的页表无对应的物理页时，会触发 Page Fault。
	Minor Page Fault（次要缺页中断）：当进程访问的页面已存在于物理内存（如页缓存或共享内存中），但尚未映射到该进程的页表中时，触发次要缺页中断。
	Major Page Fault（主要缺页中断）：当进程访问的页面不在物理内存中，必须从磁盘（如交换分区或文件系统）加载时，触发主要缺页中断。
多级页表（Multi-level Page Table）：为了节省页表空间，将页表也分页，形成多级结构（如二级页表、三级页表），结构体在 /linux-6.11.6/include/linux/XXXXXXXXXXX.h 中被定义。
TLB（Translation Lookaside Buffer）：是 CPU 内部的高速缓存，缓存最近的虚拟地址到物理地址的映射，避免频繁访问页表，提升性能。
换页（Page Swapping）：当物理内存不足时，操作系统可以将某些页暂时换出到磁盘（swap分区），提高内存利用率。

区（Zone）：

################################ Linux 中的页表结构（以 x86_64 架构为例） #####################################

x86_64 架构使用 4级页表（4-level paging），每级页表都存放指向下一级页表的指针：
|级别 | 名称                      | 缩写 | 作用
| -- | ------------------------ | ---- | ------------------
| 1  | Page Map Level 4         | PML4 | 顶层页表，最多支持 256TB 空间
| 2  | Page Directory Ptr Table | PDPT | 支持 512GB 空间
| 3  | Page Directory           | PD   | 支持 1GB 空间
| 4  | Page Table               | PT   | 支持 2MB 页或 4KB 页

一个 48 位虚拟地址会被分成以下部分：
	9 位 PML4 索引
	9 位 PDPT 索引
	9 位 PD 索引
	9 位 PT 索引
	12 位页内偏移
每一级页表都包含 512 个表项，每个表项大小为 8 字节。

####################################### 常见内存相关命令 #####################################################

vmstat / free / top：查看内存使用情况
ps -o min_flt,maj_flt <PID> ： 查看进程的次要/主要缺页次数
cat /proc/meminfo ：查看内存详细信息
cat /proc/self/maps：查看当前进程虚拟内存布局
cat /proc/[pid]/pagemap：查看虚拟地址映射情况（需要解析）
sudo dmidecode -t memory：查看内存插槽信息（包括空插槽）
lspci  -vv  | grep -i "Memory controller" -7：查看内存总线相关信息

   """
    print(mm_concept) 


def print_mem_wr_cmd():
    mem_wr_cmd = """
当运行一个程序，或者访问一个尚未加载到内存的数据时，系统会将数据从磁盘加载到内存。这一过程大致如下：

############################### 过程 ####################################

【1】用户发出读磁盘数据请求（例如打开文件）
应用程序调用如 read() 之类的系统调用。
系统调用会陷入内核态，操作系统内核接管处理。

【2】操作系统查找文件系统元信息，确定磁盘上的物理位置
文件系统会通过 inode 等结构找到对应文件在磁盘上的位置（扇区、块号等）。
这是逻辑地址到磁盘物理块地址的映射过程，由文件系统和磁盘调度模块处理。

【3】准备分配内存空间
操作系统会为这部分数据分配内存页面（Page），有时需要换出其他页面（触发页面置换算法）。
分配内存的过程会涉及 MMU 和页表设置。

【4】DMA 控制器发起数据传输
操作系统调用磁盘驱动（通常通过 SCSI、SATA 或 NVMe 协议），通知硬盘控制器准备传输。
DMA 控制器（Direct Memory Access） 接管数据传输：它通过 系统总线 直接把数据从磁盘搬运到内存指定地址，不需要 CPU 逐字节搬运。

【5】内存控制器（Memory Controller）接收数据
DMA 控制器将数据通过 总线（比如 PCIe） 发送到内存控制器。
内存控制器 负责协调数据在内存芯片（DRAM）上的写入操作，通常位于 CPU 内部（集成 MC）或主板上（早期架构）。

【6】数据写入内存芯片
内存控制器通过地址线/数据线将数据写入物理内存（DRAM 模块）中。

【7】CPU 访问数据：需要虚拟地址到物理地址的映射
当程序后续访问这部分内存：
  CPU 使用虚拟地址，先查 TLB（快表）：
    命中：TLB 返回物理地址；
    未命中：由 MMU 查找页表，建立虚实映射，并更新 TLB。
  找到物理地址后，通过内存控制器访问数据。
  
【8】缓存机制加速数据访问（可选步骤）
如果数据被频繁访问，CPU 的 缓存系统（L1/L2/L3 Cache） 会缓存这部分数据：
  缓存系统是靠地址标记和一致性协议（如 MESI）进行管理。
  后续 CPU 的计算单元就可以直接从缓存中读取数据，提高性能。

disk → mem 大致流程：
syscall → file system → OS 分配 Page → DMA → Mem Controller → DRAM chip（Dynamic RAM）


############################# 各组件的作用汇总 ####################################

| 组件        | 功能
| ----------- | ---------------------------------
| CPU 计算单元| 实际执行计算逻辑指令，最终使用这些数据
| 寄存器      | 临时保存关键数据（如地址、计数器、标志位）
| 缓存        | 加速访问热数据（L1/L2/L3）
| 内存控制器  | 管理数据在内存芯片中的读写；桥接 CPU 和 DRAM
| MMU         | 管理虚拟地址到物理地址的映射
| TLB         | 快速缓存页表中的地址映射，加速地址转换
| 内存芯片    | 最终保存数据的物理存储介质
| 总线        | 通信载体；负责 CPU、内存、硬盘、DMA 控制器等之间的数据传输 
| DMA 控制器  | 直接将磁盘数据搬运到内存，减少 CPU 负担
| 磁盘控制器  | 接收 OS 请求，控制磁盘读取操作


############################# other ####################################

**DDR 类型内存（Double Data Rate SDRAM）**是一类主流的动态随机访问内存（DRAM），
具有 在一个时钟周期内传输两次数据（上升沿 + 下降沿） 的能力，因此称为“双倍数据速率”。

| 名称  | 频率范围       | 带宽（理论）   | 电压 | 特点
| ----- | -------------- | -------------- | ---- | ----------------
| DDR1  | 200–400 MHz    | 最多 3.2 GB/s  | 2.5V | 初代 DDR
| DDR2  | 400–1066 MHz   | 最多 8.5 GB/s  | 1.8V | 更低功耗，更高频率
| DDR3  | 800–2133 MHz   | 最多 17 GB/s   | 1.5V | 普及度高，双倍带宽
| DDR4  | 1600–3200 MHz  | 最多 25.6 GB/s | 1.2V | 更快，能效更好
| DDR5  | 4800–8400+ MHz | 高达 67.2 GB/s | 1.1V | 更高带宽，支持更多并发访问
| LPDDR | 低功耗 DDR     | 多用于移动设备 |      | 比如手机、平板用的 LPDDR5
   """
    print(mem_wr_cmd) 


def print_mm_cmd():
    print("mm usage command:")
    mm_cmd = """
mm -n
   """
    print(mm_cmd) 

