#!/usr/bin/python
# -*- coding: utf-8 -*-

def print_cpu_register_cmd():
    cpu_register_cmd = """

CPU 中的寄存器是处理器内部速度最快的存储单元，用于暂存数据、地址和指令控制信息。寄存器的种类和数量因
架构（如 x86、x86-64、ARM 等）不同而略有差异。下面以 x86 和 x86-64 架构为主来说明常见寄存器类型

############################## 通用寄存器（General-Purpose Registers）######################################
名称		32 位		64 位		用途简述（可变通用）
累加器		EAX		RAX		用于算术运算、函数返回值等
基址寄存器	EBX		RBX		用作基址地址，也可用于通用数据操作
计数器		ECX		RCX		用于循环计数，rep 指令中的计数寄存器
数据寄存器	EDX		RDX		用于乘除法运算，函数返回值（64 位系统）
源索引		ESI		RSI		用于字符串操作、函数调用的参数
目标索引	EDI		RDI		用于字符串操作、函数调用的参数
栈指针		ESP		RSP		指向栈顶
基指针		EBP		RBP		指向当前栈帧底部，函数调用/调试用
新增（64 位）	无		R8~R15	        64 位架构新增的 8 个通用寄存器

############################## 段寄存器（Segment Registers，主要用于实模式） ###############################
名称		用途说明
CS		代码段（Code Segment）
DS		数据段（Data Segment）
SS		堆栈段（Stack Segment）
ES		扩展数据段（Extra Segment）
FS		额外段寄存器，线程局部存储等用途
GS		同上，多用于操作系统特殊用途

# 程序中使用的库文件本身，比如 .so 文件（共享库），并不会直接存放在某个寄存器中。CPU 寄存器是用来临时存放指令执行中
# 涉及的数据或地址的，它们空间非常小（如64位，128位等），不可能容纳整个库文件。
# 虽然库文件本身不在寄存器中，但寄存器可能临时包含，调用库函数的参数（如 %rdi, %rsi, %rdx...）；
# 库函数的入口地址（如跳转前暂存在 %rip 或栈中）；
# 从库函数返回的结果（比如 %rax 寄存器保存返回值）；
# 库文件 → 加载到内存中，执行函数时 → 函数地址/参数/返回值等通过寄存器临时处理。寄存器中从不直接“存放”库文件。

############################## 指令指针寄存器（Instruction Pointer） ######################################
名称		说明
EIP		32 位系统中的指令指针
RIP		64 位系统中的指令指针

# 说明：存储下一条要执行的指令地址。

############################## 标志寄存器（Flags Register） ##############################################
名称	描述
EFLAGS	32 位状态控制寄存器，包含多种标志位
RFLAGS	64 位版本，控制和反映程序运行状态

常见标志位（部分）：
	ZF（Zero Flag）：结果是否为零
	CF（Carry Flag）：是否产生进位/借位
	SF（Sign Flag）：符号位
	OF（Overflow Flag）：溢出标志
	IF（Interrupt Flag）：是否允许中断

############################## 控制寄存器（Control Registers，特权模式使用） ##############################
主要用于内存管理、分页机制等（主要是 x86）：
	CR0：启用保护模式等
	CR2：页面错误线性地址
	CR3：页目录基址
	CR4：启用分页扩展、SMEP 等

############################## 调试寄存器（DR0~DR7） #####################################################
用于硬件调试断点设置。

############################## 浮点与SIMD寄存器（高级寄存器） ###########################################
FPU（x87）寄存器栈：ST(0)~ST(7)
SSE/AVX：XMM0XMM15、YMM0YMM15、ZMM0~ZMM31（AVX-512）


############################## 查看寄存器属性 ###########################################################

在 Linux 中，普通用户不能直接查看 CPU 寄存器的内容或属性，因为寄存器是 CPU 内部硬件资源，通常只有在以下几种情况或工具下可以间接查看或使用：
	一、使用 gdb 调试器查看寄存器（最常用方法）
		gdb ./your_program
		(gdb) start        	  # 启动调试
		(gdb) info registers  # 查看所有通用寄存器
	二、使用 perf, lscpu, cpuid 等工具查看CPU支持哪些寄存器特性（如SSE、AVX）
		cpuid | less	# 提供更详细的寄存器扩展支持信息

############################## 系统调用约定（x86_64 架构） ###############################################

在 64位CPU（x86_64架构） 上运行的 Linux系统中，系统调用号是存放在 RAX 寄存器 中的

作用 		| 寄存器 	| 说明
系统调用号	| RAX 		| 表示要执行的系统调用，比如 60 是 exit
第1个参数 	| RDI 		| 参数1，比如文件描述符、进程ID等
第2个参数 	| RSI 		| 参数2
第3个参数 	| RDX 		| 参数3
第4个参数 	| R10 		| 参数4（注意不是 RCX！）
第5个参数 	| R8 		| 参数5
第6个参数 	| R9 		| 参数6
返回值    	| RAX 		| 系统调用的返回结果，若出错，返回负的 errno 编号
中断触发  	| syscall 	| 固定使用 syscall 指令（而非 int 0x80）
   """
    print(cpu_register_cmd) 

def print_cpu_cache_cmd():
    cpu_cache_cmd = """
############################## 存储 ######################################

#### 架构层次关系图（从快到慢，从小到大） ####
[ 寄存器 ]     <-- 最快、最小（几十个，单位是bit）
    ↓
[ L1 Cache ]   <-- 一级缓存（几十KB）
    ↓
[ L2 Cache ]   <-- 二级缓存（几百KB到几MB）
    ↓
[ L3 Cache ]   <-- 三级缓存（几MB到几十MB，多个核心共享）
    ↓
[ 主内存 (RAM) ] <-- 几GB到上百GB
    ↓
[ 磁盘/SSD ]

#### 每层的作用和特点 ####

名称		位置	大小			速度				作用
寄存器		CPU内部	几十个（每个64位）	最快（1个CPU时钟周期内）	存放当前正在执行的指令、数据、参数、结果等
L1 Cache	CPU内部	32KB~128KB		非常快				每个核心独享，缓存最近访问的指令和数据
L2 Cache	CPU内部	256KB~1MB		快				每个核心独享，缓存较近访问过的数据
L3 Cache	CPU内部	4MB~64MB		较快				多个核心共享，缓存所有核心之间的共享数据
RAM		主板上	GB级			慢得多				存储程序运行时的所有数据和代码

### 常见的 CPU 按照功能/用途分类 ####
缓存类型				说明
数据缓存（Data Cache）			存储程序运行时频繁访问的数据，如变量、数组等
指令缓存（Instruction Cache）		存储CPU即将执行的指令序列，加快程序执行速度
统一缓存（Unified Cache）		同时存放指令和数据（通常是L2或L3级别）
TLB（Translation Lookaside Buffer）	虚拟地址 → 物理地址的快速映射缓存（不属于 L1/L2/L3，但也是缓存）

### 常见的 CPU 按照层级分类（常说的 L1/L2/L3） ####
层级			子类型					说明
L1 Cache	L1d（数据）L1i（指令）		通常是两个独立的缓存，分别用于数据和指令，最接近CPU核心，速度最快
L2 Cache	Unified Cache			一般为统一缓存，既缓存指令也缓存数据，容量比L1大但稍慢
L3 Cache	Unified Cache			多核心共享，容量最大，速度相对慢，但仍远快于内存

#### 它们之间是怎么配合工作的？ ####
当CPU要执行某个指令：
	1.首先在寄存器中寻找需要的数据；
	2.没有就去 L1 Cache；
	3.再没有就去 L2 Cache；
	4.然后是 L3 Cache；
	5.最后访问 主内存（RAM）；
	6.如果主内存中也没有，就触发缺页异常，从磁盘加载。
缓存的本质作用：加快数据访问速度，尽量少访问慢速内存。

#### 举个真实的比喻 ####
寄存器 = 你手上正拿着的笔和纸；
L1 Cache = 你桌上的常用参考书；
L2 Cache = 你书架上的资料；
L3 Cache = 办公室共享资料柜；
RAM = 图书馆里借来的书；
磁盘 = 仓库里的书，借一次很慢；

#### 延迟对比（参考） ####
层级			访问延迟（大致）
寄存器		1 CPU周期（ns级）
L1 Cache	~4 CPU周期
L2 Cache	~10 CPU周期
L3 Cache	~30-50 CPU周期
主内存		~100-200 CPU周期
磁盘（SSD）	几万 CPU周期以上

# 如果你想看某一层的实际情况（比如寄存器使用、缓存命中率等），也可以用工具（如 perf, gdb, valgrind）来监控和分析 ####
工具		用途				擅长分析内容
perf		轻量级性能监测			缓存访问/未命中、CPU周期、热点函数等
gdb		调试工具，观察寄存器、栈、内存	实时查看寄存器值、断点、单步执行
valgrind	详细分析缓存和内存使用		精确到函数级的缓存命中率
   """
    print(cpu_cache_cmd) 

def print_cpu_cmd():
    cpu_cmd = """
CPU（中央处理器，Central Processing Unit）是计算机的核心部件之一，负责解释计算机指令以及处理
程序中的数据。其组成结构可以从逻辑结构和物理结构两个维度来理解。以下是典型现代CPU的逻辑组成结构：

######################## CPU的主要组成部分（逻辑结构） ####################################

| 组成部分                     | 作用                                                 
| ---------------------------- | ---------------------------------------------------------------------- 
| **算术逻辑单元（ALU）**      | 执行整数的加减乘除、逻辑运算（与、或、非、异或等）等操作
| **寄存器（Registers）**      | 内部高速小容量存储单元，用于暂存数据和指令，例如通用寄存器、程序计数器（PC）、状态寄存器等
| **控制单元（Control Unit）** | 负责指令的解码、时序控制、发出各种控制信号协调各部分工作
| **指令寄存器（IR）**         | 保存当前正在执行的指令
| **程序计数器（PC）**         | 保存下一条指令的地址
| **总线接口单元（BIU）**      | 与外部内存、I/O设备交换数据
| **浮点运算单元（FPU）**      | 执行浮点数相关的加减乘除等复杂运算
| **高速缓存（Cache）**        | 存储最近使用的数据或指令，加快访问速度，通常分为一级缓存（L1）、二级缓存（L2）、三级缓存（L3）
| **译码器（Decoder）**        | 将机器指令翻译为控制信号，供控制单元使用
| **流水线（Pipeline）**       | 将一条指令的执行过程拆分为多个阶段，使多条指令并发执行，提高效率
| **分支预测单元（BPU）**      | 预测程序跳转方向，减少分支延迟带来的性能损耗
| **乱序执行单元（OoOE）**     | 打乱指令顺序执行，但确保结果逻辑正确，提高并行度

######################## CPU的物理组成结构（芯片层面） ####################################

| 组成单元                        | 描述                                     
| ------------------------------- | --------------------------------------------------------------- 
| **核心（Core）**                | 现代CPU往往有多个核心，每个核心可以独立处理任务
| **线程（Thread）**              | 每个核心可能支持多线程技术（如Intel超线程），一个核心可同时处理多个线程
| **缓存（L1/L2/L3 Cache）**      | L1是每个核心私有的，L2可能是私有或共享，L3通常是多个核心共享的
| **封装（Package）**             | 包含多个核心、缓存、内存控制器、I/O接口等
| **互联网络（Ring Bus / Mesh）** | 在多核结构中，用于核心之间和缓存之间的数据通信
| **集成内存控制器（IMC）**       | 直接控制主内存（RAM）访问，现代CPU常集成该模块
| **集成图形处理单元（iGPU）**    | 一些CPU中集成有图形单元，用于图形渲染（如Intel的部分CPU）

########################### CPU工作基本流程简述 ####################################

1、取指（Fetch）：从内存中获取下一条指令，加载到IR；
2、译码（Decode）：由控制单元将指令翻译成控制信号；
3、执行（Execute）：由ALU或FPU执行指令对应的操作；
4、访存（Memory access）：如有需要，对数据进行读写；
5、写回（Write back）：将结果写入寄存器或内存。

########################### 现代CPU的高级特性 ####################################
1、多核并行处理（Multi-core）
2、超线程技术（Hyper-threading）
3、动态频率调节（如Intel Turbo Boost）
4、指令集扩展（如SSE、AVX）
5、安全特性（如Intel SGX、AMD SEV）

############################### advantage ####################################

MMU（Memory Management Unit，内存管理单元）既属于CPU的逻辑组成部分，也有明确电路实现的关键模块
   """
    print(cpu_cmd) 

def print_cpu_mode_cmd():
    cpu_mode_cmd = """
“实模式（Real Mode）”和“保护模式（Protected Mode）”是x86架构处理器在运行时支持的两种主
要工作模式，关系到CPU如何访问内存、如何运行程序、是否支持多任务、虚拟内存、权限等机制。

########################### 实模式（Real Mode） ####################################

1. 概念
	实模式是x86处理器上电或重启后的默认运行模式，最早用于8086处理器。它是一种简单、直接的模式，几乎没有任何保护机制。

2. 特点
	内存访问限制： 只能访问 1MB 地址空间（20位地址总线）。
	没有内存保护机制： 所有程序都能访问任意地址，容易出现程序之间互相干扰。
	分段寻址： 使用段寄存器（如CS、DS）和偏移地址来组成物理地址：
	物理地址 = 段地址 × 16 + 偏移量
	不能支持多任务或虚拟内存
	兼容8086汇编代码

3. 使用场景
	BIOS程序（如开机启动自检）
	引导加载器（如GRUB）
	DOS系统

######################### 保护模式（Protected Mode） ####################################

1. 概念
	从80286处理器开始引入，后在80386中大幅增强。它是现代操作系统（如Linux、Windows）赖以运行的模式。

2. 特点
	内存寻址增强： 支持最大4GB（32位下）或更大（64位下）的虚拟地址空间。
	支持内存保护： 每个程序只能访问其被分配的内存段，防止非法访问。
	分页机制（Paging）： 支持虚拟内存，实现内存的按页管理。
	多任务支持： 操作系统可调度多个进程并控制它们的运行。
	权限控制： 支持不同级别的权限（Ring 0~Ring 3），区分内核态和用户态。

3. 使用场景
	所有现代操作系统（Linux、Windows等）都在保护模式下运行。
	内核加载完成后就会进入保护模式。

############################## 两者关系与切换 ####################################

启动流程简述（以PC为例）：
	1、上电后，CPU以 实模式 启动。
	2、BIOS 加载并运行。
	3、BIOS加载引导程序（如GRUB）→引导程序运行于实模式。
	4、引导程序加载内核。
	5、内核将CPU切换到 保护模式 并开始操作系统运行。


############################### 小结对比表 ####################################

| 特性        | 实模式               | 保护模式
| ----------- | -------------------- | -------------------------- 
| 内存地址空间| 1MB                  | 最大4GB（32位）或更多（64位）
| 内存保护    | 无                   | 有（段保护和页保护）
| 多任务支持  | 无                   | 有
| 权限机制    | 无                   | 有（Ring 0\~3）
| 虚拟内存支持| 不支持               | 支持
| 使用场景    | BIOS、引导阶段、DOS等| 操作系统运行、内核模式等


################################# tips ####################################

cpu 特权级
mytool.py --show cpu_privilege
   """
    print(cpu_mode_cmd) 

